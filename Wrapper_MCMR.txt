using MCMRSimulator; 
using MRIBuilder; 
using LinearAlgebra; 
using StaticArrays; 
using GLMakie; 
using GeometryBasics;
using Plots

function NoColSpheres(size::Float64, td::Float64, mean::Float64, var::Float64, max_iter::Int64, min_r::Float64, max_r::Float64)

	positions, radii = random_positions_radii(
		(size, size, size), #box_size
		td, #target_density
		3, #n_dimensions for sphere
		mean = mean,
		variance = var,
		max_iter = max_iter,
		min_radius = min_r,
		max_radius = max_r
	)


 	geometry = Spheres(
		radius = radii,
		position = positions,
		R1_surface = 0.1,
		R1_inside = 0.1,
		R2_surface = 0.1,
		R2_inside = 0.1,
		off_resonance_surface = 0.0,
		off_resonance_inside = 0.0,
		use_boundingbox = false,
		size_scale = 0.5
	)

	return geometry
end


	for c2 in geometry #Loop over all cylinders

		for p1 in c1.control_point.value #point on 'spline' cylinder 1

			for p2 in c2.control_point.value #point on 'spline' cylinder 2

				if abs(p1[3] - p2[3]) > 0.1
					continue
				end

				distance = norm(p1 .- p2)
				threshold = c1.radius.value + c2.radius.value 
				#println("dist = $distance, threshold = $threshold")
		\
				if distance < threshold #collision occurs if dist < their radii sum
					return true
				end
			end
		end
	end
	return false
end

function CylGen(z_step::Int64, z_gap::Float64, tortuosity::Float64, spline::Int64, min_r::Float64, max_r::Float64, xy_bound::Float64)

	Start = [rand(-xy_bound:0.01:xy_bound), rand(-xy_bound:0.01:xy_bound), 0.0]

	c_p = [Start .+ [rand(-0.05:0.005:0.05)*tortuosity, rand(-0.05:0.005:0.05)*tortuosity, z_gap*j] for j in 0:z_step]

	geometry_bendy = BendyCylinder(
		control_point = c_p,
		radius = rand(min_r:0.005:max_r),
		spline_order = spline,
		myelin = true,
		use_boundingbox = true
		#use default rotation
	)
	
	return geometry_bendy

end

function NoColCylinder(N::Int64, max_attempts::Int64, z_step::Int64, z_gap::Float64, tortuosity::Float64, spline::Int, min_r::Float64, max_r::Float64, xy_bound::Float64)

	geometry = MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup\{:BendyCylinder\}[] #init vector

	for _ in 1:N

		attempts = 0

		while attempts < max_attempts

			new_cyl = CylGen(z_step, z_gap, tortuosity, spline, min_r, max_r, xy_bound) #generate cylinders for the nth time

			if check_collision(new_cyl, geometry) == true

				attempts += 1

			else

				push!(geometry, new_cyl) #add new cylinder
				println("Valid solution found at attempt: $attempts")
				break

			end
		end

		if attempts == max_attempts
			error("Too many attempts without finding a valid solution.")

		end
	end
	return geometry
end

	TR = t_rep

	for i in 1:k
		sequence[i] = DWI(
			bval = i*b_step, 
			TE = t_echo, 
			TR = t_rep, 
			scanner = Siemens_Prisma
		)
		f = plot_sequence(sequence[i])
	end

	return sequence, TR\

end

function Sim(sequence, geometry, T1::Int64, T2::Int64, diffusivity::Float64, end_time::Float64, n_spins::Int64, TR)

	simulation = Simulation(
		sequence, 
		R1 = 1/T1, 
		R2 = 1/T2, 
		diffusivity = diffusivity, 
		off_resonance = 0.1, 
		geometry = geometry)

	time = 0:0.1:end_time
	n_spins = n_spins

	if end_time > TR
		error(
"End time cannot exceed TR.")

	end
	return simulation, n_spins, time


function ReadIndex(simulation, n_spins::Int64, time, skip_TR::Int64, nTR::Int64, sim_i::Int, nTR_i::Int, l_t::Int)

	avg_signals = readout(
		n_spins,       # Number of spins to be simulated
         	simulation, 
         	time,
        		skip_TR = skip_TR, # Dummy cycles to stabilize re-magnetization
        		nTR = nTR,
        		return_snapshot = false
    		)


	if sim_i > size(avg_signals, 1)
        		error("sim_i exceeds the number of simulations in avg_signals.")
    	end

	if nTR_i > nTR
       		error("nTR_i exceeds the number of TR cycles in avg_signals.")
    	end

   	if l_t == 1

        		signal_type = "Transverse"
        		signals = transverse.(avg_signals[sim_i, :, nTR_i])
		
		Plots.scatter(time, signals,
			xlabel = "Time (ms)",
			ylabel = "Transverse Signal Strength",
			title = "Transverse Signal against time",
			legend = false)

    	elseif l_t == 2

        		signal_type = "Longitudinal"
        		signals = longitudinal.(avg_signals[sim_i, :, nTR_i])

		Plots.scatter(time, signals,
			xlabel = "Time (ms)",
			ylabel = "Longitudinal Signal Strength",
			title = "Longitudinal Signal against time",
			legend = false)

    	else 

        		error("Invalid l_t value. Use 1 for Transverse or 2 for Longitudinal signals.")

    	end
    	return signals, signal_type

end

function MCMRSim(
               geo_mode::Int64, # Defines which geometry
               geo_params::Tuple, # Defines what parameters
               seq_params::Tuple, # Defines sequence parameters
               sim_params::NamedTuple, # Defines simulation parameters
               out_params::NamedTuple # Defines readout and indexing parameters
               )

	geometry = nothing

	if geo_mode == 1

		geometry = NoColSpheres(geo_params...)
        		plot(geometry)

    	elseif geo_mode == 2

        		geometry = NoColCylinder(geo_params...)
        		plot(geometry)

   	else
        		error("Invalid geo_mode. Enter 1 for Spheres or 2 for Bendy Cylinders.")

    	end

    	sequence, TR = B_Iter(seq_params...)

    	sim_params_up = NamedTuple{(:sequence, :geometry, :T1, :T2, :diffusivity, :end_time, :n_spins, :TR)}(
        		(sequence, geometry, sim_params.T1, sim_params.T2, sim_params.diffusivity, sim_params.end_time, sim_params.n_spins, TR)
    	)

    	simulation, n_spins, time = Sim(sim_params_up...)

    	out_params_up = NamedTuple{(:simulation, :n_spins, :time, :skip_TR, :nTR, :sim_i, :nTR_i, :l_t)}(
        		(simulation, n_spins, time, out_params.skip_TR, out_params.nTR, out_params.sim_i, out_params.nTR_i, out_params.l_t)
    	)

    	signals, signal_type = ReadIndex(out_params_up...)

    	return signals, signal_type

end

geo_mode = 1 
geo_params = (2.0, 0.6, 1.0, 0.5, 1000, 0.1, 0.2) 
seq_params = (0.05, 10, 80, 300) 
sim_params = (T1 = 780, T2 = 90, diffusivity = 2.0, end_time = 299., n_spins = 100) 
out_params = (skip_TR = 1, nTR = 3, sim_i = 1, nTR_i = 1, l_t = 1) 

signals, signal_type = MCMRSim(geo_mode, geo_params, seq_params, sim_params, out_params)
println("Signals: ", signals)
println("Signal Type: ", signal_type)
