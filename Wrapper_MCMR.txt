{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fswiss\fcharset0 Helvetica;\f2\fswiss\fcharset0 Helvetica-Bold;
\f3\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red22\green21\blue22;\red255\green255\blue255;\red255\green255\blue255;
\red0\green0\blue0;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c11373\c10980\c11373;\cssrgb\c100000\c100000\c100000;\cssrgb\c100000\c100000\c100000;
\csgray\c0;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww23320\viewh15940\viewkind0
\deftab560
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0

\f0\fs24 \cf0 using CairoMakie; \
using MCMRSimulator; \
using MRIBuilder; \
using LinearAlgebra; \
using StaticArrays; \
using GLMakie; \
using GeometryBasics;\
using Plots\
\pard\pardeftab560\slleading20\partightenfactor0
\cf0 \
function NoColSpheres(size::Float64, td::Float64, mean::Float64, var::Float64, max_iter::Int64, min_r::Float64, max_r::Float64)\
\
	positions, radii = random_positions_radii(\
		(size, size, size), #box_size\
		td, #target_density\
		3, #n_dimensions for sphere\
		mean = mean,\
		variance = var,\
		max_iter = max_iter,\
		min_radius = min_r,\
		max_radius = max_r\
	)\
\
\pard\pardeftab560\slleading20\pardirnatural\partightenfactor0
\cf0 	geometry = Spheres(\
		radius = radii,\
		position = positions,\
		R1_surface = 0.1,\
		R1_inside = 0.1,\
		R2_surface = 0.1,\
		R2_inside = 0.1,\
		off_resonance_surface = 0.0,\
		off_resonance_inside = 0.0,\
		use_boundingbox = false,\
		size_scale = 0.5\
	)\
\
	return geometry\
end\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \expnd0\expndtw0\kerning0
function check_collision(c1::MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup\{:BendyCylinder\}, geometry::Vector\{MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup\{:BendyCylinder\}\})\
\
	for c2 in geometry #Loop over all cylinders\
\
		for p1 in c1.control_point.value #point on 'spline' cylinder 1\
\
			for p2 in c2.control_point.value #point on 'spline' cylinder 2\
\
				if abs(p1[3] - p2[3]) > 0.1\
					continue\
				end\
\
				distance = norm(p1 .- p2)\
				threshold = c1.radius.value + c2.radius.value \
				#println("dist = $distance, threshold = $threshold")\
		\
				if distance < threshold #collision occurs if dist < their radii sum\
					return true\
				end\
			end\
		end\
	end\
	return false\
end\
\
function CylGen(z_step::Int64, z_gap::Float64, tortuosity::Float64, spline::Int64, min_r::Float64, max_r::Float64, xy_bound::Float64)\
\
	Start = [rand(-xy_bound:0.01:xy_bound), rand(-xy_bound:0.01:xy_bound), 0.0]\
\
	c_p = [Start .+ [rand(-0.05:0.005:0.05)*tortuosity, rand(-0.05:0.005:0.05)*tortuosity, z_gap*j] for j in 0:z_step]\
\
	geometry_bendy = BendyCylinder(\
		control_point = c_p,\
		radius = rand(min_r:0.005:max_r),\
		spline_order = spline,\
		myelin = true,\
		use_boundingbox = true\
		#use default rotation\
	)\
	\
	return geometry_bendy\
\
end\
\
function NoColCylinder(N::Int64, max_attempts::Int64, z_step::Int64, z_gap::Float64, tortuosity::Float64, spline::Int, min_r::Float64, max_r::Float64, xy_bound::Float64)\
\
	geometry = MCMRSimulator.Geometries.User.Obstructions.ObstructionGroups.ObstructionGroup\{:BendyCylinder\}[] #init vector\
\
	for _ in 1:N\
\
		attempts = 0\
\
		while attempts < max_attempts\
\
			new_cyl = CylGen(z_step, z_gap, tortuosity, spline, min_r, max_r, xy_bound) #generate cylinders for the nth time\
\
			if check_collision(new_cyl, geometry) == true\
\
				attempts += 1\
\
			else\
\
				push!(geometry, new_cyl) #add new cylinder\
				println("Valid solution found at attempt: $attempts")\
				break\
\
			end\
		end\
\
		if attempts == max_attempts\
			error("Too many attempts without finding a valid solution.")\
\
		end\
	end\
	return geometry\
end\
\
\
\
\pard\pardeftab560\slleading20\partightenfactor0
\cf0 \cb1 \kerning1\expnd0\expndtw0 function B_Iter(b_step, k, t_echo, t_rep)\
\
	\expnd0\expndtw0\kerning0
sequence = Vector\{Any\}(undef, k) #Initialization, holds upcoming values\
\kerning1\expnd0\expndtw0 \
	TR = t_rep\
\
	for i in 1:k\
		sequence[i] = DWI(\
			bval = i*b_step, \
			TE = t_echo, \
			TR = t_rep, \
			scanner = Siemens_Prisma\
		)\
		f = plot_sequence(sequence[i])\
	end\
\
	return sequence, TR\
\
end\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb4 \expnd0\expndtw0\kerning0
\
\pard\pardeftab560\slleading20\partightenfactor0
\cf0 \cb1 \kerning1\expnd0\expndtw0 \
function Sim(sequence, geometry, T1::Int64, T2::Int64, diffusivity::Float64, end_time::Float64, n_spins::Int64, TR)\
\
	simulation = Simulation(\
		sequence, \
		R1 = 1/T1, \
		R2 = 1/T2, \
		diffusivity = diffusivity, \
		off_resonance = 0.1, \
		geometry = geometry)\
\
	time = 0:0.1:end_time\
	n_spins = n_spins\
\
	if end_time > TR\
		error(\cf2 \cb4 \expnd0\expndtw0\kerning0
"End time cannot exceed TR.")\
\
	end\
	return simulation, n_spins, time\
\
end\cf0 \cb1 \kerning1\expnd0\expndtw0 \
\
\pard\pardeftab560\slleading20\partightenfactor0
\cf2 \cb4 \expnd0\expndtw0\kerning0
\
\
function ReadIndex(simulation, n_spins::Int64, time, skip_TR::Int64, nTR::Int64, sim_i::Int, nTR_i::Int, l_t::Int)\
\
	avg_signals = readout(\
		n_spins,       # Number of spins to be simulated\
         	simulation, \
         	time,\
        		skip_TR = skip_TR, # Dummy cycles to stabilize re-magnetization\
        		nTR = nTR,\
        		return_snapshot = false\
    		)\
\
\
	if sim_i > size(avg_signals, 1)\
        		error("sim_i exceeds the number of simulations in avg_signals.")\
    	end\
\
	if nTR_i > nTR\
       		error("nTR_i exceeds the number of TR cycles in avg_signals.")\
    	end\
\
   	if l_t == 1\
\
        		signal_type = "Transverse"\
        		signals = transverse.(avg_signals[sim_i, :, nTR_i])\
		\
		Plots.scatter(time, signals,\
			xlabel = "Time (ms)",\
			ylabel = "Transverse Signal Strength",\
			title = "Transverse Signal against time",\
			legend = false)\
\
    	elseif l_t == 2\
\
        		signal_type = "Longitudinal"\
        		signals = longitudinal.(avg_signals[sim_i, :, nTR_i])\
\
		Plots.scatter(time, signals,\
			xlabel = "Time (ms)",\
			ylabel = "Longitudinal Signal Strength",\
			title = "Longitudinal Signal against time",\
			legend = false)\
\
    	else \
\
        		error("Invalid l_t value. Use 1 for Transverse or 2 for Longitudinal signals.")\
\
    	end\
    	return signals, signal_type\
\
end\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1 \cf0 \cb1 \kerning1\expnd0\expndtw0 \
\
function MCMRSim(\
               geo_mode::Int64, # Defines which geometry\
               geo_params::Tuple, # Defines what parameters\
               seq_params::Tuple, # Defines sequence parameters\
               sim_params::NamedTuple, # Defines simulation parameters\
               out_params::NamedTuple # Defines readout and indexing parameters\
               )\
\
	geometry = nothing\
\
	if geo_mode == 1\
\
		geometry = NoColSpheres(geo_params...)\
        		plot(geometry)\
\
    	elseif geo_mode == 2\
\
        		geometry = NoColCylinder(geo_params...)\
        		plot(geometry)\
\
   	else\
        		error("Invalid geo_mode. Enter 1 for Spheres or 2 for Bendy Cylinders.")\
\
    	end\
\
    	sequence, TR = B_Iter(seq_params...)\
\
    	sim_params_up = NamedTuple\{(:sequence, :geometry, :T1, :T2, :diffusivity, :end_time, :n_spins, :TR)\}(\
        		(sequence, geometry, sim_params.T1, sim_params.T2, sim_params.diffusivity, sim_params.end_time, sim_params.n_spins, TR)\
    	)\
\
    	simulation, n_spins, time = Sim(sim_params_up...)\
\
    	out_params_up = NamedTuple\{(:simulation, :n_spins, :time, :skip_TR, :nTR, :sim_i, :nTR_i, :l_t)\}(\
        		(simulation, n_spins, time, out_params.skip_TR, out_params.nTR, out_params.sim_i, out_params.nTR_i, out_params.l_t)\
    	)\
\
    	signals, signal_type = ReadIndex(out_params_up...)\
\
    	return signals, signal_type\
\
end\
\
geo_mode = 1 \
geo_params = (2.0, 0.6, 1.0, 0.5, 1000, 0.1, 0.2) \
seq_params = (0.05, 10, 80, 300) \
sim_params = (T1 = 780, T2 = 90, diffusivity = 2.0, end_time = 299., n_spins = 100) \
out_params = (skip_TR = 1, nTR = 3, sim_i = 1, nTR_i = 1, l_t = 1) \
\
signals, signal_type = MCMRSim(geo_mode, geo_params, seq_params, sim_params, out_params)\
println("Signals: ", signals)\
println("Signal Type: ", signal_type)\
\
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \cb4 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\partightenfactor0

\f2\b\fs28 \cf0 \cb1 \kerning1\expnd0\expndtw0 UNUSED, UNDER DEVELOPMENT FUNCTIONS AND TO-BE-IMPLEMENTED FEATURES
\fs24 \
\
\pard\pardeftab560\slleading20\partightenfactor0

\f0\b0 \cf0 function Direction(dir)\
\
	u_x, u_y, u_z = dir\
\
	origin = Point3f0(0.0, 0.0, 0.0)\
\
	fig = Figure()\
	ax = LScene(fig[1, 1], scenekw=(show_axis=true, ))\
\
	arrows!(ax, [origin], [u_x], arrowsize=0.2, color=:red, label="X")\
	arrows!(ax, [origin], [u_y], arrowsize=0.2, color=:green, label="Y")\
	arrows!(ax, [origin], [u_z], arrowsize=0.2, color=:blue, label="Z")\
\
	nested_vector = [[p[1], p[2], p[3]] for p in dir] #Nested tuple of float32s valid for arrows, but vector for sequence dir.\
\
	return fig, nested_vector\
end\
\
direction = ((1.0, 0.2, 0.5), (0.2, 0.8, 0.6), (0.5, 0.4, 0.9))
\f2\b \
\pard\pardeftab720\partightenfactor0
\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural\partightenfactor0

\f0\b0 \cf5 \CocoaLigature0 function B_Iter(b_step, k, t_echo, t_rep, grad_dir_1, grad_dir_2)\
\
               sequence = Vector\{Any\}(undef, k) #Initialization, holds upcoming values\
\
               for i in 1:k\
                       sequence[i] = DWI(\
                               bval = i*b_step, \
                               TE = t_echo, \
                               TR = t_rep, \
                               scanner = Siemens_Prisma\
                       )\
\
                       og = sequence[i].gradient\
                       og_2 = sequence[i].gradient2\
\
                       ng = MRIBuilder.Parts.Trapezoids.Trapezoid1D(\
                               og.rise_time,\
                               og.flat_time,\
                               og.slew_rate,\
                               grad_dir_1,\
                               og.group\
                       )\
\
                       ng2 = MRIBuilder.Parts.Trapezoids.Trapezoid1D(\
                               og2.rise_time,\
                               og2.flat_time,\
                               og2.slew_rate,\
                               grad_dir_2,\
                               og2.group\
                       )\
\
                       sequence[i] = MRIBuilder.Sequences.DiffusionSpinEchoes(\
                               bval = sequence[i].bval,\
                               TE = sequence[i].TE,\
                               TR = sequence[i].TR,\
                               scanner = sequence[i].scanner,\
                               gradient = ng,\
                               gradient2 = ng2\
                       )\
\
                       f = plot_sequence(sequence[i])\
               end\
\
               return sequence\
\
       end\cf2 \cb4 \expnd0\expndtw0\kerning0
\CocoaLigature1 \
\pard\pardeftab720\partightenfactor0
\cf2 	
\f3 \cf0 \cb1 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 	
\f1 \kerning1\expnd0\expndtw0 \
	}
